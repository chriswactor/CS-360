# CS-360
inventory App Reflection
My app, InventoryApp_ChrisWactor, was designed to help users easily manage and track their inventory using a simple, user-friendly interface. The main goal was to allow users to log in or create accounts, add and remove items, update quantities, and store all information in a persistent SQLite database. It also includes an optional SMS notification feature that alerts users when inventory levels drop below a set amount. This app was created to meet the needs of small business owners or individuals who want to manage stock efficiently from their phones.

To meet user needs, I focused on keeping the interface clean and straightforward. The login screen provides a secure way to store and access user data, while the main screen shows an organized grid of items that can be easily edited or updated. The design uses logical grouping and a consistent layout to keep the user experience smooth and intuitive. My UI decisions were centered around accessibility, reducing confusion, and making sure users could quickly complete their tasks without extra steps.

When coding the app, I took a modular approach — keeping my logic separated into clear sections. For example, LoginActivity manages user authentication, MainActivity manages the database display, and DBHelper and Repository classes handle data operations. This made it easier to debug and maintain. I also used inline comments and consistent naming conventions to improve readability. Testing in the Android Emulator allowed me to fix issues early and confirm that both new and existing user accounts worked correctly. These techniques are useful for any future app development, especially when working with data-driven applications.

Testing was done through the Android Emulator by logging in, adding and deleting inventory items, and simulating different permission scenarios for SMS notifications. This process was critical for catching logic errors, verifying database persistence, and ensuring that the app still functioned correctly even when certain permissions were denied. Testing revealed the importance of error handling and user feedback, such as Toast messages for invalid inputs or denied permissions.

One of the biggest challenges was managing multiple screens and keeping the app from crashing during transitions — especially when handling user logins and database updates. I had to innovate by restructuring the database helper logic and separating responsibilities across different classes. Once I refined the structure, everything worked more smoothly.

The strongest part of my project was successfully combining user authentication, a persistent database, and permission-based notifications into one fully functional Android app. This project demonstrated my ability to plan, design, and code an app from start to finish while following user-centered design principles and mobile development best practices.
